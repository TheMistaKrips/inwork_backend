================================================================================
Ğ˜Ğ¡Ğ¥ĞĞ”ĞĞ«Ğ™ ĞšĞĞ” ĞŸĞ ĞĞ•ĞšĞ¢Ğ
Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: C:\Users\MSI\Desktop\InWork\backend
Ğ’ÑĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: 10
================================================================================


â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python (10 Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²)
â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: auth.py                                                                â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\auth.py                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from pydantic import BaseModel
import hashlib
import base64
import os

# ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
SECRET_KEY = "your-secret-key-change-in-production-please-change-this"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

class UserCreate(BaseModel):
    email: str
    password: str
    full_name: str
    is_freelancer: bool = False

class UserResponse(BaseModel):
    id: int
    email: str
    full_name: str
    is_freelancer: bool

    class Config:
        from_attributes = True

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ Ñ ÑĞ¾Ğ»ÑŒÑ"""
    try:
        # Ğ Ğ°Ğ·Ğ´ĞµĞ»ÑĞµĞ¼ Ñ…ĞµÑˆ Ğ¸ ÑĞ¾Ğ»ÑŒ
        if ":" not in hashed_password:
            return False
        
        salt, stored_hash = hashed_password.split(":")
        
        # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ñ…ĞµÑˆ Ğ¾Ñ‚ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ + ÑĞ¾Ğ»ÑŒ
        computed_hash = hashlib.sha256((plain_password + salt).encode()).hexdigest()
        
        return computed_hash == stored_hash
    except:
        return False

def get_password_hash(password: str) -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ…ĞµÑˆĞ° Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ Ñ ÑĞ¾Ğ»ÑŒÑ"""
    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½ÑƒÑ ÑĞ¾Ğ»ÑŒ
    salt = base64.b64encode(os.urandom(16)).decode('utf-8')
    
    # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ñ…ĞµÑˆ Ğ¾Ñ‚ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ + ÑĞ¾Ğ»ÑŒ
    password_hash = hashlib.sha256((password + salt).encode()).hexdigest()
    
    # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ "ÑĞ¾Ğ»ÑŒ:Ñ…ĞµÑˆ"
    return f"{salt}:{password_hash}"

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: chat_server.py                                                         â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\chat_server.py               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import asyncio
import json
from datetime import datetime
from typing import Dict, Set
from fastapi import WebSocket, WebSocketDisconnect
from sqlalchemy.orm import Session
from database import SessionLocal
import models
import auth

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[int, WebSocket] = {}
        self.user_rooms: Dict[int, Set[str]] = {}

    async def connect(self, websocket: WebSocket, user_id: int, room_id: str):
        await websocket.accept()
        self.active_connections[user_id] = websocket
        if user_id not in self.user_rooms:
            self.user_rooms[user_id] = set()
        self.user_rooms[user_id].add(room_id)
        print(f"User {user_id} connected to room {room_id}")

    def disconnect(self, user_id: int, room_id: str):
        if user_id in self.active_connections:
            del self.active_connections[user_id]
        if user_id in self.user_rooms and room_id in self.user_rooms[user_id]:
            self.user_rooms[user_id].remove(room_id)
        print(f"User {user_id} disconnected from room {room_id}")

    async def send_personal_message(self, message: dict, user_id: int):
        if user_id in self.active_connections:
            try:
                await self.active_connections[user_id].send_json(message)
            except Exception as e:
                print(f"Error sending to user {user_id}: {e}")

    async def broadcast_to_room(self, message: dict, room_id: str, exclude_user_id: int = None):
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼ Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ
        for user_id, rooms in self.user_rooms.items():
            if room_id in rooms and user_id != exclude_user_id:
                await self.send_personal_message(message, user_id)

manager = ConnectionManager()

async def websocket_endpoint(websocket: WebSocket, user_id: int, order_id: int):
    room_id = f"order_{order_id}"
    
    await manager.connect(websocket, user_id, room_id)
    
    try:
        while True:
            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
            data = await websocket.receive_text()
            message_data = json.loads(data)
            
            # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² Ğ±Ğ°Ğ·Ñƒ
            db = SessionLocal()
            try:
                message = models.ChatMessage(
                    order_id=order_id,
                    sender_id=user_id,
                    message=message_data["message"],
                    message_type=message_data.get("type", "text")
                )
                db.add(message)
                db.commit()
                db.refresh(message)
                
                # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸
                response = {
                    "type": "message",
                    "id": message.id,
                    "order_id": order_id,
                    "sender_id": user_id,
                    "message": message.message,
                    "message_type": message.message_type,
                    "created_at": message.created_at.isoformat(),
                    "is_own": False  # Ğ”Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»Ñ
                }
                
                # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²ÑĞµĞ¼ Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ ĞºÑ€Ğ¾Ğ¼Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»Ñ
                await manager.broadcast_to_room(response, room_id, user_id)
                
                # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»Ñ
                confirm_response = response.copy()
                confirm_response["is_own"] = True
                await manager.send_personal_message(confirm_response, user_id)
                
            except Exception as e:
                print(f"Error saving message: {e}")
            finally:
                db.close()
                
    except WebSocketDisconnect:
        manager.disconnect(user_id, room_id)
    except Exception as e:
        print(f"WebSocket error: {e}")
        manager.disconnect(user_id, room_id)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: code.py                                                                â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\code.py                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import argparse
from pathlib import Path

def should_skip_directory(dir_name):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ"""
    skip_dirs = {
        'node_modules', '.git', 'build', 'dist', 'coverage', 
        '.next', '.nuxt', '.cache', 'assets', 'static',
        'public', '.vscode', '.idea', '__pycache__', 'cache',
        'logs', 'temp', 'tmp', 'vendor', 'bin', 'obj'
    }
    return dir_name in skip_dirs or dir_name.startswith('.')

def should_skip_file(file_name):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ‚ÑŒ Ñ„Ğ°Ğ¹Ğ»"""
    skip_files = {
        'package.json', 'package-lock.json', 'yarn.lock',
        'tsconfig.json', 'webpack.config.js', '.eslintrc.js',
        '.prettierrc', 'babel.config.js', 'next.config.js',
        'jest.config.js', 'vue.config.js', 'nuxt.config.js',
        '.gitignore', '.env', '.env.local', 'README.md'
    }
    return file_name in skip_files

def is_target_file(file_name):
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ»Ğ¸ Ñ„Ğ°Ğ¹Ğ» Ñ†ĞµĞ»ĞµĞ²Ñ‹Ğ¼ (JS/JSX/TS/TSX Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹)"""
    target_extensions = {
        '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
        '.css', '.scss', '.less', '.html', '.htm', '.json',
        '.py', '.java', '.cpp', '.c', '.h', '.cs', '.php',
        '.rb', '.go', '.rs', '.swift', '.kt', '.dart'
    }
    return any(file_name.endswith(ext) for ext in target_extensions)

def get_file_category(file_extension):
    """Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ´Ğ»Ñ Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸"""
    categories = {
        '.js': 'JavaScript',
        '.jsx': 'React JSX',
        '.ts': 'TypeScript', 
        '.tsx': 'React TypeScript',
        '.vue': 'Vue',
        '.svelte': 'Svelte',
        '.py': 'Python',
        '.html': 'HTML',
        '.css': 'CSS',
        '.scss': 'SCSS',
        '.less': 'LESS',
        '.json': 'JSON',
        '.java': 'Java',
        '.cpp': 'C++',
        '.c': 'C',
        '.cs': 'C#',
        '.php': 'PHP',
        '.rb': 'Ruby',
        '.go': 'Go',
        '.rs': 'Rust',
        '.swift': 'Swift',
        '.kt': 'Kotlin',
        '.dart': 'Dart'
    }
    return categories.get(file_extension, 'Other')

def format_file_header(file_path, relative_path, category):
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    header = []
    header.append("â•”" + "â•" * 78 + "â•—")
    header.append(f"â•‘ Ğ¤ĞĞ™Ğ›: {relative_path:<70} â•‘")
    header.append(f"â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: {category:<65} â•‘")
    header.append(f"â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: {file_path:<64} â•‘")
    header.append("â•š" + "â•" * 78 + "â•")
    return '\n'.join(header)

def format_file_footer():
    """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ²Ğ°Ğ» Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    return "\n" + "â”€" * 80 + "\n"

def collect_source_files(root_dir, output_file):
    """Ğ ĞµĞºÑƒÑ€ÑĞ¸Ğ²Ğ½Ğ¾ ÑĞ¾Ğ±Ğ¸Ñ€Ğ°ĞµÑ‚ Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ Ğ¸Ñ… Ğ² output_file"""
    
    root_path = Path(root_dir)
    files_by_category = {}
    total_files = 0
    
    print("ğŸ” Ğ¡ĞºĞ°Ğ½Ğ¸Ñ€ÑƒÑ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°...")
    
    # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ²ÑĞµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼
    for root, dirs, files in os.walk(root_dir):
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ
        dirs[:] = [d for d in dirs if not should_skip_directory(d)]
        
        for file in files:
            if should_skip_file(file):
                continue
                
            if is_target_file(file):
                file_path = Path(root) / file
                relative_path = file_path.relative_to(root_path)
                file_extension = file_path.suffix.lower()
                category = get_file_category(file_extension)
                
                if category not in files_by_category:
                    files_by_category[category] = []
                
                files_by_category[category].append((file_path, relative_path))
                total_files += 1
    
    print(f"ğŸ“ ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ {total_files} Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ² {len(files_by_category)} ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑÑ…")
    
    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ», ÑĞ³Ñ€ÑƒĞ¿Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼
    with open(output_file, 'w', encoding='utf-8') as out_f:
        # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°
        out_f.write("=" * 80 + "\n")
        out_f.write(f"Ğ˜Ğ¡Ğ¥ĞĞ”ĞĞ«Ğ™ ĞšĞĞ” ĞŸĞ ĞĞ•ĞšĞ¢Ğ\n")
        out_f.write(f"Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: {root_dir}\n")
        out_f.write(f"Ğ’ÑĞµĞ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {total_files}\n")
        out_f.write("=" * 80 + "\n\n")
        
        # ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸ÑĞ¼ Ğ² Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ
        for category in sorted(files_by_category.keys()):
            files_in_category = files_by_category[category]
            
            # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
            out_f.write("\n" + "â– " * 80 + "\n")
            out_f.write(f"ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: {category} ({len(files_in_category)} Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²)\n")
            out_f.write("â– " * 80 + "\n\n")
            
            # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¿Ğ¾ Ğ¿ÑƒÑ‚Ğ¸
            for file_path, relative_path in sorted(files_in_category, key=lambda x: str(x[1])):
                try:
                    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ñ„Ğ°Ğ¹Ğ»Ğ°
                    out_f.write(format_file_header(str(file_path), str(relative_path), category))
                    out_f.write("\n\n")
                    
                    # Ğ§Ğ¸Ñ‚Ğ°ĞµĞ¼ Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ°
                    with open(file_path, 'r', encoding='utf-8') as in_f:
                        content = in_f.read().rstrip()  # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ»Ğ¸ÑˆĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹ Ğ² ĞºĞ¾Ğ½Ñ†Ğµ
                        out_f.write(content)
                    
                    # Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ´Ğ²Ğ°Ğ» Ñ„Ğ°Ğ¹Ğ»Ğ°
                    out_f.write(format_file_footer())
                    
                    print(f"âœ… ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½: {relative_path}")
                    
                except UnicodeDecodeError:
                    try:
                        # ĞŸÑ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ´Ñ€ÑƒĞ³ÑƒÑ ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²ĞºÑƒ
                        with open(file_path, 'r', encoding='cp1251') as in_f:
                            content = in_f.read().rstrip()
                            out_f.write(content)
                        out_f.write(format_file_footer())
                        print(f"âœ… ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½ (Windows-1251): {relative_path}")
                    except Exception as e:
                        out_f.write(f"// âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}\n")
                        out_f.write(format_file_footer())
                        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {relative_path} - {e}")
                        
                except Exception as e:
                    out_f.write(f"// âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}\n")
                    out_f.write(format_file_footer())
                    print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {relative_path} - {e}")

def main():
    parser = argparse.ArgumentParser(
        description='ğŸ“ Ğ¡Ğ±Ğ¾Ñ€Ñ‰Ğ¸Ğº Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ° Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° - ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ» ÑĞ¾ Ğ²ÑĞµĞ¼ ĞºĞ¾Ğ´Ğ¾Ğ¼',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('--input', '-i', default='.', 
                       help='Ğ’Ñ…Ğ¾Ğ´Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ)')
    parser.add_argument('--output', '-o', default='project_code.txt',
                       help='Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ» (Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ project_code.txt)')
    
    args = parser.parse_args()
    
    input_dir = os.path.abspath(args.input)
    output_file = args.output
    
    if not os.path.exists(input_dir):
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ {input_dir} Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚!")
        return
    
    print("ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞ±Ğ¾Ñ€Ñ‰Ğ¸ĞºĞ° Ğ¸ÑÑ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°...")
    print(f"ğŸ“‚ Ğ˜ÑÑ…Ğ¾Ğ´Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: {input_dir}")
    print(f"ğŸ’¾ Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ¹ Ñ„Ğ°Ğ¹Ğ»: {output_file}")
    print("-" * 60)
    
    collect_source_files(input_dir, output_file)
    
    print("-" * 60)
    print(f"ğŸ‰ Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾!")
    print(f"ğŸ“„ Ğ’ÑĞµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ñ‹ Ğ²: {output_file}")

if __name__ == "__main__":
    main()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: create_test_data.py                                                    â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\create_test_data.py          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from sqlalchemy.orm import Session
from database import engine, SessionLocal
import models
import auth
from datetime import datetime, timedelta

def create_test_data():
    db = SessionLocal()
    
    try:
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)
        db.query(models.Bid).delete()
        db.query(models.Order).delete()
        db.query(models.User).delete()
        db.commit()
        
        print("Ğ¡Ñ‚Ğ°Ñ€Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ñ‹")
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
        hashed_password = auth.get_password_hash("test123")
        test_client = models.User(
            email="client@test.ru",
            full_name="Ğ˜Ğ²Ğ°Ğ½ ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²",
            hashed_password=hashed_password,
            is_freelancer=False
        )
        db.add(test_client)
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ°
        hashed_password_freelancer = auth.get_password_hash("test123")
        test_freelancer = models.User(
            email="freelancer@test.ru",
            full_name="ĞŸĞµÑ‚Ñ€ Ğ¤Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ¾Ğ²",
            hashed_password=hashed_password_freelancer,
            is_freelancer=True
        )
        db.add(test_freelancer)
        
        db.commit()
        db.refresh(test_client)
        db.refresh(test_freelancer)
        
        print(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ¸ĞµĞ½Ñ‚: {test_client.email}")
        print(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€: {test_freelancer.email}")
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
        orders_data = [
            {
                "title": "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ»Ñ IT ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸",
                "description": "Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ€Ñ‚Ğ°Ğ¿Ğ° Ğ² ÑÑ„ĞµÑ€Ğµ Ğ¸ÑĞºÑƒÑÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚Ğ°. Ğ›Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¾Ñ‚Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒ Ñ‚ĞµÑ…Ğ½Ğ¾Ğ»Ğ¾Ğ³Ğ¸Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¸ Ğ¸Ğ½Ğ½Ğ¾Ğ²Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ.",
                "requirements": "â€¢ Ğ’ĞµĞºÑ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ (AI, SVG)\nâ€¢ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½\nâ€¢ Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²Ğ°Ñ Ğ³Ğ°Ğ¼Ğ¼Ğ°: ÑĞ¸Ğ½Ğ¸Ğµ/Ğ³Ğ¾Ğ»ÑƒĞ±Ñ‹Ğµ Ñ‚Ğ¾Ğ½Ğ°\nâ€¢ ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ´ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ Ğ½Ğ¾ÑĞ¸Ñ‚ĞµĞ»Ğ¸\nâ€¢ Ğ¡Ñ€Ğ¾Ğº: 7 Ğ´Ğ½ĞµĞ¹",
                "budget": 5000,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=7)
            },
            {
                "title": "ĞĞ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑŒĞ¸ Ğ¿Ñ€Ğ¾ Ğ²ĞµĞ±-Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ",
                "description": "ĞÑƒĞ¶Ğ½Ğ° Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ğ¾ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ°Ñ… Ğ´Ğ»Ñ Ñ„Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ½Ğ° 2024 Ğ³Ğ¾Ğ´. Ğ¡Ñ‚Ğ°Ñ‚ÑŒÑ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ Ğ¿Ğ¾Ğ»ĞµĞ·Ğ½Ğ° ĞºĞ°Ğº Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ°Ğ¼, Ñ‚Ğ°Ğº Ğ¸ Ğ¾Ğ¿Ñ‹Ñ‚Ğ½Ñ‹Ğ¼ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ°Ğ¼.",
                "requirements": "â€¢ ĞĞ±ÑŠĞµĞ¼: 3000-3500 ÑĞ»Ğ¾Ğ²\nâ€¢ Ğ£Ğ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ: 95%+\nâ€¢ SEO-Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ\nâ€¢ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ ĞºĞ¾Ğ´Ğ°\nâ€¢ Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¾Ğ²\nâ€¢ Ğ¡Ñ€Ğ¾Ğº: 5 Ğ´Ğ½ĞµĞ¹",
                "budget": 3000,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=5)
            },
            {
                "title": "Ğ’ĞµÑ€ÑÑ‚ĞºĞ° Ğ»ĞµĞ½Ğ´Ğ¸Ğ½Ğ³Ğ° Ğ´Ğ»Ñ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-ĞºÑƒÑ€ÑĞ°",
                "description": "Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ ÑĞ²ĞµÑ€ÑÑ‚Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ´Ğ°ÑÑ‰ÑƒÑ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-ĞºÑƒÑ€ÑĞ° Ğ¿Ğ¾ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ. Ğ›ĞµĞ½Ğ´Ğ¸Ğ½Ğ³ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¼, Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¼ Ğ¸ ĞºĞ¾Ğ½Ğ²ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¼.",
                "requirements": "â€¢ ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑÑ‚ĞºĞ° (Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğµ, Ğ¿Ğ»Ğ°Ğ½ÑˆĞµÑ‚Ñ‹, Ğ´ĞµÑĞºÑ‚Ğ¾Ğ¿)\nâ€¢ ĞĞ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° CSS/JS\nâ€¢ Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ„Ğ¾Ñ€Ğ¼Ñ‹ Ğ·Ğ°ÑĞ²ĞºĞ¸\nâ€¢ ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚Ğ¸ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸\nâ€¢ ĞšÑ€Ğ¾ÑÑĞ±Ñ€Ğ°ÑƒĞ·ĞµÑ€Ğ½Ğ¾ÑÑ‚ÑŒ\nâ€¢ Ğ¡Ñ€Ğ¾Ğº: 10 Ğ´Ğ½ĞµĞ¹",
                "budget": 8000,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=10)
            },
            {
                "title": "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Telegram Ğ±Ğ¾Ñ‚Ğ° Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²",
                "description": "ĞÑƒĞ¶ĞµĞ½ Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿Ñ€Ğ¸ĞµĞ¼Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ² Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¼ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ½ĞµÑ‚-Ğ¼Ğ°Ğ³Ğ°Ğ·Ğ¸Ğ½Ğµ. Ğ‘Ğ¾Ñ‚ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¸ Ñ„Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ñ‹.",
                "requirements": "â€¢ Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ±Ğ°Ğ·Ğ¾Ğ¹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…\nâ€¢ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹ Ñ‡ĞµÑ€ĞµĞ· Ğ®Kassa\nâ€¢ ĞĞ´Ğ¼Ğ¸Ğ½-Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ\nâ€¢ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ² Telegram\nâ€¢ Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² Excel\nâ€¢ Ğ¡Ñ€Ğ¾Ğº: 14 Ğ´Ğ½ĞµĞ¹",
                "budget": 15000,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=14)
            },
            {
                "title": "Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ",
                "description": "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° UI/UX Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğ° Ğ´Ğ»Ñ Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ´Ğ¾ÑÑ‚Ğ°Ğ²ĞºĞ¸ ĞµĞ´Ñ‹. ĞŸÑ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ğ±Ñ‹Ñ‚ÑŒ ÑƒĞ´Ğ¾Ğ±Ğ½Ñ‹Ğ¼, ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¼ Ğ¸ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ñ€ĞµĞ½Ğ´Ğ°Ğ¼ 2024 Ğ³Ğ¾Ğ´Ğ°.",
                "requirements": "â€¢ Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½ 10+ ÑĞºÑ€Ğ°Ğ½Ğ¾Ğ²\nâ€¢ ĞŸÑ€Ğ¾Ñ‚Ğ¾Ñ‚Ğ¸Ğ¿Ñ‹ Ğ² Figma\nâ€¢ Ğ ÑƒĞºĞ¾Ğ²Ğ¾Ğ´ÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾ ÑÑ‚Ğ¸Ğ»Ñ\nâ€¢ ĞĞ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ´ iOS Ğ¸ Android\nâ€¢ ĞĞ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°\nâ€¢ Ğ¡Ñ€Ğ¾Ğº: 12 Ğ´Ğ½ĞµĞ¹",
                "budget": 12000,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=12)
            }
        ]
        
        orders = []
        for order_data in orders_data:
            order = models.Order(**order_data)
            db.add(order)
            orders.append(order)
        
        db.commit()
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¸ (Ğ±Ğ¸Ğ´Ñ‹)
        bids_data = [
            {
                "order_id": orders[0].id,
                "freelancer_id": test_freelancer.id,
                "amount": 4500,
                "proposal": "Ğ£ Ğ¼ĞµĞ½Ñ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ğ¾Ğ¿Ñ‹Ñ‚ Ğ² Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½Ğµ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿Ğ¾Ğ² Ğ´Ğ»Ñ IT-ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¹. Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ğ·Ğ° 5 Ğ´Ğ½ĞµĞ¹, Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»Ñ 3 Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚Ğ° Ğ½Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€.",
                "status": "pending"
            },
            {
                "order_id": orders[1].id,
                "freelancer_id": test_freelancer.id,
                "amount": 2500,
                "proposal": "Ğ¯ Ñ‚ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ¸ÑĞ°Ñ‚ĞµĞ»ÑŒ Ñ 5-Ğ»ĞµÑ‚Ğ½Ğ¸Ğ¼ Ğ¾Ğ¿Ñ‹Ñ‚Ğ¾Ğ¼. ĞĞ°Ğ¿Ğ¸ÑˆÑƒ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ñ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°Ğ¼Ğ¸ Ğ¸ Ğ°ĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ¸ÑÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ğ½Ğ¸ÑĞ¼Ğ¸.",
                "status": "accepted"
            },
            {
                "order_id": orders[2].id,
                "freelancer_id": test_freelancer.id,
                "amount": 7000,
                "proposal": "Ğ’ĞµÑ€ÑÑ‚Ğ°Ñ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ»ĞµĞ½Ğ´Ğ¸Ğ½Ğ³Ğ¸ Ñ Ğ°Ğ½Ğ¸Ğ¼Ğ°Ñ†Ğ¸ÑĞ¼Ğ¸ Ğ¸ Ğ²Ñ‹ÑĞ¾ĞºĞ¾Ğ¹ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒÑ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Tailwind CSS Ğ¸ GSAP.",
                "status": "pending"
            }
        ]
        
        for bid_data in bids_data:
            bid = models.Bid(**bid_data)
            db.add(bid)
        
        # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ° (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ±Ñ‹Ğ» Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ñ‹Ğ¹ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº)
        accepted_order = orders[1]
        accepted_order.freelancer_id = test_freelancer.id
        accepted_order.status = "in_progress"
        
        db.commit()
        
        print(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ {len(orders)} Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²")
        print(f"Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ {len(bids_data)} Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ²")
        print("\nĞ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ñ‹ Ğ´Ğ»Ñ Ğ²Ñ…Ğ¾Ğ´Ğ°:")
        print("ĞšĞ»Ğ¸ĞµĞ½Ñ‚: client@test.ru / test123")
        print("Ğ¤Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€: freelancer@test.ru / test123")
        print("\nĞ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹!")
        
    except Exception as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        import traceback
        traceback.print_exc()
        db.rollback()
    finally:
        db.close()

if __name__ == "__main__":
    # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
    from database import Base
    Base.metadata.create_all(bind=engine)
    
    create_test_data()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: database.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\database.py                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ´Ğ»Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…, ĞµÑĞ»Ğ¸ ĞµÑ‘ Ğ½ĞµÑ‚
if not os.path.exists('data'):
    os.makedirs('data')

SQLALCHEMY_DATABASE_URL = "sqlite:///./data/vrabote.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: init_db.py                                                             â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\init_db.py                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from sqlalchemy.orm import Session
from database import engine, SessionLocal, Base
import models
import auth

def init_database():
    """Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸"""
    
    print("ğŸ”„ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ† Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
    
    # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğµ
    Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine)
    
    db = SessionLocal()
    
    try:
        print("ğŸ‘¥ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹...")
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
        hashed_password = auth.get_password_hash("test123")
        test_client = models.User(
            email="test@test.ru",
            full_name="Ğ¢ĞµÑÑ‚ ĞšĞ»Ğ¸ĞµĞ½Ñ‚",
            hashed_password=hashed_password,
            is_freelancer=False
        )
        db.add(test_client)
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ°
        hashed_password_freelancer = auth.get_password_hash("test123")
        test_freelancer = models.User(
            email="freelancer@test.ru",
            full_name="Ğ¢ĞµÑÑ‚ Ğ¤Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€",
            hashed_password=hashed_password_freelancer,
            is_freelancer=True
        )
        db.add(test_freelancer)
        
        db.commit()
        db.refresh(test_client)
        db.refresh(test_freelancer)
        
        print(f"âœ… Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ¸ĞµĞ½Ñ‚: {test_client.email} / test123")
        print(f"âœ… Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€: {test_freelancer.email} / test123")
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
        from datetime import datetime, timedelta
        
        print("ğŸ“¦ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²...")
        
        orders_data = [
            {
                "title": "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ»Ñ IT ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸",
                "description": "Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ€Ñ‚Ğ°Ğ¿Ğ° Ğ² ÑÑ„ĞµÑ€Ğµ Ğ¸ÑĞºÑƒÑÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµĞ»Ğ»ĞµĞºÑ‚Ğ°.",
                "requirements": "Ğ’ĞµĞºÑ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ (AI, SVG), Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸ÑÑ‚Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½, Ñ†Ğ²ĞµÑ‚Ğ¾Ğ²Ğ°Ñ Ğ³Ğ°Ğ¼Ğ¼Ğ°: ÑĞ¸Ğ½Ğ¸Ğµ/Ğ³Ğ¾Ğ»ÑƒĞ±Ñ‹Ğµ Ñ‚Ğ¾Ğ½Ğ°",
                "budget": 5000.0,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=7)
            },
            {
                "title": "ĞĞ°Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑŒĞ¸ Ğ¿Ñ€Ğ¾ Ğ²ĞµĞ±-Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ",
                "description": "ĞÑƒĞ¶Ğ½Ğ° Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ğ¾ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ñ… Ñ„Ñ€ĞµĞ¹Ğ¼Ğ²Ğ¾Ñ€ĞºĞ°Ñ… Ğ´Ğ»Ñ Ñ„Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ½Ğ° 2024 Ğ³Ğ¾Ğ´.",
                "requirements": "ĞĞ±ÑŠĞµĞ¼: 3000-3500 ÑĞ»Ğ¾Ğ², ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ: 95%+, SEO-Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ",
                "budget": 3000.0,
                "client_id": test_client.id,
                "deadline": datetime.utcnow() + timedelta(days=5)
            },
        ]
        
        for order_data in orders_data:
            order = models.Order(**order_data)
            db.add(order)
        
        db.commit()
        
        print("âœ… Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°!")
        print("\nğŸ“‹ Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ:")
        print("1. ĞšĞ»Ğ¸ĞµĞ½Ñ‚: test@test.ru / test123")
        print("2. Ğ¤Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€: freelancer@test.ru / test123")
        print("3. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¾ 2 Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ°")
        
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        import traceback
        traceback.print_exc()
        db.rollback()
    finally:
        db.close()

if __name__ == "__main__":
    init_database()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: main.py                                                                â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\main.py                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import asyncio
from fastapi import FastAPI, Depends, HTTPException, status, WebSocket, WebSocketDisconnect, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy import func, or_, and_
from sqlalchemy.orm import Session
from typing import Dict, List, Optional, Set
from jose import JWTError, jwt
from datetime import datetime, timedelta
from pydantic import BaseModel
import json
import models
import auth
from database import engine, get_db, SessionLocal
import traceback

# Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
models.Base.metadata.create_all(bind=engine)

app = FastAPI(title="Ğ’Ğ Ğ°Ğ±Ğ¾Ñ‚Ğµ API", version="1.0.0")

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:8081",
        "http://localhost:19006",
        "exp://192.168.10.106:8081",
        "http://192.168.10.106:19006",
        "http://192.168.10.106:19000",
        "*"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Ğ¡Ñ…ĞµĞ¼Ğ° OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# WebSocket Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.user_rooms: Dict[str, Set[str]] = {}

    async def connect(self, websocket: WebSocket, client_id: str, room_id: str):
        await websocket.accept()
        self.active_connections[client_id] = websocket
        if client_id not in self.user_rooms:
            self.user_rooms[client_id] = set()
        self.user_rooms[client_id].add(room_id)
        print(f"âœ… Client {client_id} connected to room {room_id}")

    def disconnect(self, client_id: str, room_id: str):
        if client_id in self.active_connections:
            del self.active_connections[client_id]
        if client_id in self.user_rooms and room_id in self.user_rooms[client_id]:
            self.user_rooms[client_id].remove(room_id)
        print(f"âŒ Client {client_id} disconnected from room {room_id}")

    async def send_personal_message(self, message: dict, client_id: str):
        if client_id in self.active_connections:
            try:
                await self.active_connections[client_id].send_json(message)
            except Exception as e:
                print(f"Error sending to client {client_id}: {e}")

    async def broadcast_to_room(self, message: dict, room_id: str, exclude_client_id: str = None):
        for client_id, rooms in self.user_rooms.items():
            if room_id in rooms and client_id != exclude_client_id:
                await self.send_personal_message(message, client_id)

manager = ConnectionManager()

# ĞœĞ¾Ğ´ĞµĞ»Ğ¸ Pydantic
class OrderCreate(BaseModel):
    title: str
    description: str
    requirements: str
    budget: float
    deadline: Optional[datetime] = None
    category: Optional[str] = "other"

class OrderResponse(BaseModel):
    id: int
    title: str
    description: str
    requirements: str
    budget: float
    status: str
    created_at: datetime
    client_id: int
    deadline: Optional[datetime] = None
    freelancer_id: Optional[int] = None
    category: Optional[str] = None

    class Config:
        from_attributes = True

class BidCreate(BaseModel):
    order_id: int
    amount: float
    proposal: str
    portfolio_links: Optional[str] = None

class BidResponse(BaseModel):
    id: int
    order_id: int
    freelancer_id: int
    amount: float
    proposal: str
    status: str
    created_at: datetime
    portfolio_links: Optional[str] = None
    freelancer_name: Optional[str] = None
    order_title: Optional[str] = None

    class Config:
        from_attributes = True

class ChatMessageCreate(BaseModel):
    message: str
    message_type: str = "text"

class ReviewCreate(BaseModel):
    order_id: int
    rating: int
    comment: str

class ReviewReply(BaseModel):
    reply_text: str

class NotificationResponse(BaseModel):
    id: int
    title: str
    body: str
    notification_type: str
    related_id: Optional[int]
    is_read: bool
    created_at: datetime

    class Config:
        from_attributes = True

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, auth.SECRET_KEY, algorithms=[auth.ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(models.User).filter(models.User.email == email).first()
    if user is None:
        raise credentials_exception
    return user

# Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
def create_notification(db: Session, user_id: int, title: str, body: str, notif_type: str, related_id: int = None):
    notification = models.Notification(
        user_id=user_id,
        title=title,
        body=body,
        notification_type=notif_type,
        related_id=related_id
    )
    db.add(notification)
    return notification

# WebSocket endpoint
@app.websocket("/ws/{order_id}")
async def websocket_endpoint(websocket: WebSocket, order_id: int):
    await websocket.accept()
    client_id = None
    user_id = None
    
    try:
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½ Ğ¸Ğ· query Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ¾Ğ²
        token = websocket.query_params.get("token")
        if not token:
            print("âŒ No token provided in WebSocket connection")
            await websocket.close(code=1008, reason="No token provided")
            return
        
        print(f"ğŸ”‘ Token received: {token[:20]}...")
            
        # Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾ĞºĞµĞ½
        try:
            payload = jwt.decode(token, auth.SECRET_KEY, algorithms=[auth.ALGORITHM])
            user_email = payload.get("sub")
            
            if not user_email:
                print("âŒ No email in token payload")
                await websocket.close(code=1008, reason="Invalid token: no email")
                return
            
            db = SessionLocal()
            user = db.query(models.User).filter(models.User.email == user_email).first()
            db.close()
            
            if not user:
                print(f"âŒ User not found for email: {user_email}")
                await websocket.close(code=1008, reason="User not found")
                return
                
            user_id = user.id
            client_id = f"user_{user_id}_order_{order_id}"
            
            print(f"âœ… User authenticated: {user_email} (ID: {user_id})")
            
        except jwt.ExpiredSignatureError:
            print("âŒ Token expired")
            await websocket.close(code=1008, reason="Token expired")
            return
        except jwt.JWTError as e:
            print(f"âŒ JWT error: {e}")
            await websocket.close(code=1008, reason=f"Invalid token: {str(e)}")
            return
        except Exception as e:
            print(f"âŒ Token verification error: {e}")
            await websocket.close(code=1008, reason="Token verification failed")
            return
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ¸Ğ¼ĞµĞµÑ‚ Ğ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ·Ğ°ĞºĞ°Ğ·Ñƒ
        db = SessionLocal()
        order = db.query(models.Order).filter(models.Order.id == order_id).first()
        db.close()
        
        if not order:
            print(f"âŒ Order {order_id} not found")
            await websocket.close(code=1008, reason="Order not found")
            return
            
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ
        if user_id not in [order.client_id, order.freelancer_id]:
            print(f"âŒ User {user_id} has no access to order {order_id}")
            await websocket.close(code=1008, reason="No access to this order")
            return
        
        room_id = f"order_{order_id}"
        
        # ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        await manager.connect(websocket, client_id, room_id)
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ
        await websocket.send_json({
            "type": "connection_established",
            "message": "WebSocket connected successfully",
            "user_id": user_id,
            "order_id": order_id
        })
        
        print(f"âœ… WebSocket connection established for user {user_id} to order {order_id}")
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
        db = SessionLocal()
        messages = db.query(models.ChatMessage).filter(
            models.ChatMessage.order_id == order_id
        ).order_by(models.ChatMessage.created_at.desc()).limit(20).all()
        db.close()
        
        # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞµ (Ğ¾Ñ‚ ÑÑ‚Ğ°Ñ€Ñ‹Ñ… Ğº Ğ½Ğ¾Ğ²Ñ‹Ğ¼)
        for msg in reversed(messages):
            try:
                await websocket.send_json({
                    "type": "new_message",
                    "id": msg.id,
                    "sender_id": msg.sender_id,
                    "message": msg.message,
                    "created_at": msg.created_at.isoformat(),
                    "is_own": msg.sender_id == user_id
                })
            except Exception as e:
                print(f"Error sending message history: {e}")
        
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ» Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹
        try:
            while True:
                # Ğ–Ğ´ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¾Ñ‚ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° Ñ Ñ‚Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚Ğ¾Ğ¼
                try:
                    data = await asyncio.wait_for(websocket.receive_json(), timeout=300.0)
                except asyncio.TimeoutError:
                    # ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ping, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ
                    try:
                        await websocket.send_json({"type": "ping"})
                        continue
                    except:
                        break  # Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ€Ğ°Ğ·Ğ¾Ñ€Ğ²Ğ°Ğ½Ğ¾
                
                print(f"ğŸ“¨ Received WebSocket message: {data}")
                
                if data.get("type") == "message":
                    # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ² Ğ±Ğ°Ğ·Ñƒ
                    db = SessionLocal()
                    try:
                        message_text = data.get("message", "").strip()
                        if not message_text:
                            await websocket.send_json({
                                "type": "error",
                                "message": "Empty message"
                            })
                            continue
                            
                        message = models.ChatMessage(
                            order_id=order_id,
                            sender_id=user_id,
                            message=message_text,
                            message_type=data.get("message_type", "text")
                        )
                        db.add(message)
                        db.commit()
                        db.refresh(message)
                        
                        # Ğ Ğ°ÑÑÑ‹Ğ»Ğ°ĞµĞ¼ Ğ²ÑĞµĞ¼ Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ
                        await manager.broadcast_to_room({
                            "type": "new_message",
                            "id": message.id,
                            "sender_id": user_id,
                            "message": message.message,
                            "created_at": message.created_at.isoformat(),
                            "is_own": False
                        }, room_id, client_id)
                        
                        # ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ĞµĞ»Ñ
                        await websocket.send_json({
                            "type": "message_sent",
                            "id": message.id,
                            "created_at": message.created_at.isoformat()
                        })
                        
                    except Exception as e:
                        print(f"Error saving message: {e}")
                        await websocket.send_json({
                            "type": "error",
                            "message": "Failed to save message"
                        })
                    finally:
                        db.close()
                
                elif data.get("type") == "ping":
                    # ĞÑ‚Ğ²ĞµÑ‡Ğ°ĞµĞ¼ Ğ½Ğ° ping
                    await websocket.send_json({"type": "pong"})
                
                elif data.get("type") == "join":
                    # Ğ£Ğ¶Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ñ‹
                    await websocket.send_json({
                        "type": "join_confirmed",
                        "user_id": user_id,
                        "order_id": order_id
                    })
                    
        except WebSocketDisconnect:
            print(f"WebSocket disconnected normally for client {client_id}")
        except Exception as e:
            print(f"WebSocket error in message loop: {e}")
                
    except WebSocketDisconnect:
        print(f"WebSocket disconnected during setup for client {client_id}")
    except Exception as e:
        print(f"WebSocket endpoint error: {e}")
    finally:
        if client_id:
            manager.disconnect(client_id, f"order_{order_id}")
        print(f"âŒ WebSocket connection closed for order {order_id}")

# Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
@app.post("/register", response_model=auth.UserResponse)
def register(user: auth.UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(models.User).filter(models.User.email == user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed_password = auth.get_password_hash(user.password)
    db_user = models.User(
        email=user.email,
        full_name=user.full_name,
        hashed_password=hashed_password,
        is_freelancer=user.is_freelancer
    )
    
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

# Ğ’Ñ…Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.email == form_data.username).first()
    if not user or not auth.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=auth.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = auth.create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user_id": user.id,
        "email": user.email,
        "full_name": user.full_name,
        "is_freelancer": user.is_freelancer
    }

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
@app.post("/orders", response_model=OrderResponse)
async def create_order(order: OrderCreate, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    if current_user.is_freelancer:
        raise HTTPException(status_code=400, detail="Freelancers cannot create orders")
    
    db_order = models.Order(
        title=order.title,
        description=order.description,
        requirements=order.requirements,
        budget=order.budget,
        client_id=current_user.id,
        deadline=order.deadline,
        category=order.category
    )
    
    db.add(db_order)
    db.commit()
    db.refresh(db_order)
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ¾Ğ²
    freelancers = db.query(models.User).filter(
        models.User.is_freelancer == True,
        models.User.is_active == True
    ).limit(20).all()
    
    for freelancer in freelancers:
        create_notification(
            db,
            freelancer.id,
            "ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· Ğ² Ğ²Ğ°ÑˆĞµĞ¹ Ğ»ĞµĞ½Ñ‚Ğµ",
            f"ĞŸĞ¾ÑĞ²Ğ¸Ğ»ÑÑ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·: '{order.title}' Ğ·Ğ° {order.budget} Ñ€ÑƒĞ±.",
            "new_order",
            db_order.id
        )
    
    db.commit()
    return db_order

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµÑ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² (Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹)
@app.get("/orders", response_model=List[OrderResponse])
async def get_orders_paginated(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        skip = (page - 1) * limit
        
        if current_user.is_freelancer:
            # Ğ”Ğ»Ñ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ° Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
            query = db.query(models.Order).filter(
                models.Order.status == "open"
            )
        else:
            # Ğ”Ğ»Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ° Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²ÑĞµ ĞµĞ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
            query = db.query(models.Order).filter(
                models.Order.client_id == current_user.id
            )
        
        orders = query.order_by(
            # ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: Ğ¿Ñ€ĞµĞ¼Ğ¸ÑƒĞ¼ -> ÑÑ€Ğ¾Ñ‡Ğ½Ñ‹Ğµ -> Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğµ
            models.Order.is_premium.desc(),
            models.Order.is_urgent.desc(),
            models.Order.created_at.desc()
        ).offset(skip).limit(limit).all()
        
        return orders
    except Exception as e:
        print(f"Error in get_orders_paginated: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¿Ğ¾ ID
@app.get("/orders/{order_id}", response_model=OrderResponse)
def get_order(order_id: int, db: Session = Depends(get_db)):
    try:
        print(f"ğŸ”„ Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° /orders/{order_id}")
        order = db.query(models.Order).filter(models.Order.id == order_id).first()
        if order is None:
            raise HTTPException(status_code=404, detail="Order not found")
        return order
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in get_order: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹)
@app.get("/my-orders", response_model=List[OrderResponse])
async def get_my_orders_paginated(
    page: int = Query(1, ge=1),
    limit: int = Query(20, ge=1, le=100),
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        skip = (page - 1) * limit
        
        if current_user.is_freelancer:
            orders = db.query(models.Order).filter(
                models.Order.freelancer_id == current_user.id,
                models.Order.status != "cancelled"
            )
        else:
            orders = db.query(models.Order).filter(
                models.Order.client_id == current_user.id,
                models.Order.status != "cancelled"
            )
        
        orders = orders.order_by(
            models.Order.created_at.desc()
        ).offset(skip).limit(limit).all()
        
        return orders
    except Exception as e:
        print(f"Error in get_my_orders_paginated: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ° Ğ¿Ğ¾ ID
@app.get("/bids/{bid_id}", response_model=BidResponse)
async def get_bid(bid_id: int, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    try:
        bid = db.query(models.Bid).filter(models.Bid.id == bid_id).first()
        if not bid:
            raise HTTPException(status_code=404, detail="Bid not found")
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
        order = db.query(models.Order).filter(models.Order.id == bid.order_id).first()
        if not order:
            raise HTTPException(status_code=404, detail="Order not found")
        
        # Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº
        if current_user.id not in [order.client_id, order.freelancer_id, bid.freelancer_id]:
            raise HTTPException(status_code=403, detail="Not authorized")
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ğµ Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
        freelancer = db.query(models.User).filter(models.User.id == bid.freelancer_id).first()
        bid_data = {
            "id": bid.id,
            "order_id": bid.order_id,
            "freelancer_id": bid.freelancer_id,
            "amount": bid.amount,
            "proposal": bid.proposal,
            "status": bid.status,
            "created_at": bid.created_at,
            "portfolio_links": bid.portfolio_links,
            "freelancer_name": freelancer.full_name if freelancer else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒ",
            "order_title": order.title
        }
        
        return bid_data
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in get_bid: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ° Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·
@app.post("/bids", response_model=BidResponse)
async def create_bid(bid: BidCreate, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    try:
        order = db.query(models.Order).filter(models.Order.id == bid.order_id).first()
        if not order:
            raise HTTPException(status_code=404, detail="Order not found")
        
        if not current_user.is_freelancer:
            raise HTTPException(status_code=400, detail="Only freelancers can create bids")
        
        if order.status != "open":
            raise HTTPException(status_code=400, detail="Order is not open for bidding")
        
        existing_bid = db.query(models.Bid).filter(
            models.Bid.order_id == bid.order_id,
            models.Bid.freelancer_id == current_user.id
        ).first()
        
        if existing_bid:
            raise HTTPException(status_code=400, detail="You have already bid on this order")
        
        db_bid = models.Bid(
            order_id=bid.order_id,
            freelancer_id=current_user.id,
            amount=bid.amount,
            proposal=bid.proposal,
            portfolio_links=bid.portfolio_links
        )
        
        db.add(db_bid)
        
        # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ½Ğ° ÑÑ‚Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ·
        bid_count = db.query(models.Bid).filter(
            models.Bid.order_id == bid.order_id
        ).count()
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ
        create_notification(
            db,
            order.client_id,
            f"ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ²Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· ({bid_count} Ğ²ÑĞµĞ³Ğ¾)",
            f"ĞĞ° Ğ²Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· '{order.title}' Ğ¿Ğ¾ÑÑ‚ÑƒĞ¿Ğ¸Ğ» Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ·Ğ° {bid.amount} Ñ€ÑƒĞ±.",
            "new_bid",
            db_bid.id
        )
        
        db.commit()
        db.refresh(db_bid)
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ğµ
        bid_response = {
            "id": db_bid.id,
            "order_id": db_bid.order_id,
            "freelancer_id": db_bid.freelancer_id,
            "amount": db_bid.amount,
            "proposal": db_bid.proposal,
            "status": db_bid.status,
            "created_at": db_bid.created_at,
            "portfolio_links": db_bid.portfolio_links,
            "freelancer_name": current_user.full_name,
            "order_title": order.title
        }
        
        return bid_response
        
    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        print(f"Error in create_bid: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
@app.get("/my-bids", response_model=List[BidResponse])
async def get_my_bids(current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    bids = db.query(models.Bid).filter(models.Bid.freelancer_id == current_user.id).all()
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ğµ Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğµ
    result = []
    for bid in bids:
        freelancer = db.query(models.User).filter(models.User.id == bid.freelancer_id).first()
        order = db.query(models.Order).filter(models.Order.id == bid.order_id).first()
        
        bid_data = {
            "id": bid.id,
            "order_id": bid.order_id,
            "freelancer_id": bid.freelancer_id,
            "amount": bid.amount,
            "proposal": bid.proposal,
            "status": bid.status,
            "created_at": bid.created_at,
            "portfolio_links": bid.portfolio_links,
            "freelancer_name": freelancer.full_name if freelancer else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒ",
            "order_title": order.title if order else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·"
        }
        result.append(bid_data)
    
    return result

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·
@app.get("/orders/{order_id}/bids", response_model=List[BidResponse])
async def get_order_bids(
    order_id: int, 
    current_user: models.User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    try:
        order = db.query(models.Order).filter(models.Order.id == order_id).first()
        if not order:
            raise HTTPException(status_code=404, detail="Order not found")
        
        # Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµĞ¼ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¾Ğ² Ğ°Ğ²Ñ‚Ğ¾Ñ€Ñƒ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        if order.client_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to view bids for this order")
        
        bids = db.query(models.Bid).filter(models.Bid.order_id == order_id).all()
        
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ğµ
        result = []
        for bid in bids:
            freelancer = db.query(models.User).filter(models.User.id == bid.freelancer_id).first()
            
            bid_data = {
                "id": bid.id,
                "order_id": bid.order_id,
                "freelancer_id": bid.freelancer_id,
                "amount": bid.amount,
                "proposal": bid.proposal,
                "status": bid.status,
                "created_at": bid.created_at,
                "portfolio_links": bid.portfolio_links,
                "freelancer_name": freelancer.full_name if freelancer else "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒ",
                "order_title": order.title
            }
            result.append(bid_data)
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in get_order_bids: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸÑ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°
@app.patch("/bids/{bid_id}/accept")
async def accept_bid(bid_id: int, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    bid = db.query(models.Bid).filter(models.Bid.id == bid_id).first()
    if not bid:
        raise HTTPException(status_code=404, detail="Bid not found")
    
    order = db.query(models.Order).filter(models.Order.id == bid.order_id).first()
    if order.client_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to accept this bid")
    
    if order.status != "open":
        raise HTTPException(status_code=400, detail="Order is not open")
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ±Ğ¸Ğ´Ğ°
    bid.status = "accepted"
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
    order.status = "in_progress"
    order.freelancer_id = bid.freelancer_id
    
    # ĞÑ‚ĞºĞ»Ğ¾Ğ½ÑĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ¸
    rejected_bids = db.query(models.Bid).filter(
        models.Bid.order_id == bid.order_id,
        models.Bid.id != bid_id
    ).all()
    
    for rejected_bid in rejected_bids:
        rejected_bid.status = "rejected"
        create_notification(
            db,
            rejected_bid.freelancer_id,
            "ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½",
            f"Ğ’Ğ°Ñˆ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ· '{order.title}' Ğ±Ñ‹Ğ» Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½",
            "bid_rejected",
            order.id
        )
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ñƒ Ğ¾ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ğ¸Ğ¸
    create_notification(
        db,
        bid.freelancer_id,
        "Ğ’Ğ°Ñˆ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚!",
        f"ĞšĞ»Ğ¸ĞµĞ½Ñ‚ Ğ¿Ñ€Ğ¸Ğ½ÑĞ» Ğ²Ğ°Ñˆ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ· '{order.title}' Ğ·Ğ° {bid.amount} Ñ€ÑƒĞ±. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ğ±ÑÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ² Ñ‡Ğ°Ñ‚Ğµ.",
        "bid_accepted",
        order.id
    )
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ñƒ
    create_notification(
        db,
        order.client_id,
        "ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚",
        f"Ğ’Ñ‹ Ğ¿Ñ€Ğ¸Ğ½ÑĞ»Ğ¸ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ¾Ñ‚ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ñ Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ· '{order.title}'. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ğ±ÑÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ² Ñ‡Ğ°Ñ‚Ğµ.",
        "bid_accepted",
        order.id
    )
    
    db.commit()
    return {"message": "Bid accepted successfully", "bid_id": bid_id, "order_id": order.id}

# ĞÑ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ĞºĞ»Ğ¸ĞºĞ°
@app.patch("/bids/{bid_id}/reject")
async def reject_bid(bid_id: int, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    bid = db.query(models.Bid).filter(models.Bid.id == bid_id).first()
    if not bid:
        raise HTTPException(status_code=404, detail="Bid not found")
    
    order = db.query(models.Order).filter(models.Order.id == bid.order_id).first()
    if order.client_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to reject this bid")
    
    if bid.status != "pending":
        raise HTTPException(status_code=400, detail="Bid is not pending")
    
    bid.status = "rejected"
    
    create_notification(
        db,
        bid.freelancer_id,
        "ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½",
        f"Ğ’Ğ°Ñˆ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ğ½Ğ° Ğ·Ğ°ĞºĞ°Ğ· '{order.title}' Ğ±Ñ‹Ğ» Ğ¾Ñ‚ĞºĞ»Ğ¾Ğ½ĞµĞ½ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ¼",
        "bid_rejected",
        order.id
    )
    
    db.commit()
    return {"message": "Bid rejected successfully", "bid_id": bid_id}

# Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
@app.patch("/orders/{order_id}/complete")
async def complete_order(order_id: int, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    order = db.query(models.Order).filter(models.Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    if order.client_id != current_user.id:
        raise HTTPException(status_code=403, detail="Only client can complete order")
    
    if order.status != "in_progress":
        raise HTTPException(status_code=400, detail="Order is not in progress")
    
    order.status = "completed"
    
    create_notification(
        db,
        order.freelancer_id,
        "Ğ—Ğ°ĞºĞ°Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½!",
        f"Ğ—Ğ°ĞºĞ°Ğ· '{order.title}' Ğ±Ñ‹Ğ» Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ¼. Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ·Ñ‹Ğ².",
        "order_completed",
        order.id
    )
    
    create_notification(
        db,
        order.client_id,
        "Ğ—Ğ°ĞºĞ°Ğ· Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½",
        f"Ğ’Ñ‹ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ğ»Ğ¸ Ğ·Ğ°ĞºĞ°Ğ· '{order.title}'.",
        "order_completed",
        order.id
    )
    
    db.commit()
    return {"message": "Order completed successfully", "order_id": order_id}

# ĞÑ‚Ğ¼ĞµĞ½Ğ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
@app.patch("/orders/{order_id}/cancel")
async def cancel_order(order_id: int, current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    order = db.query(models.Order).filter(models.Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    if order.client_id != current_user.id and current_user.id != order.freelancer_id:
        raise HTTPException(status_code=403, detail="Only order participants can cancel order")
    
    if order.status not in ["open", "in_progress"]:
        raise HTTPException(status_code=400, detail="Order cannot be cancelled")
    
    order.status = "cancelled"
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ÑĞµĞ¼ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ°
    if current_user.id == order.client_id and order.freelancer_id:
        create_notification(
            db,
            order.freelancer_id,
            "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½",
            f"Ğ—Ğ°ĞºĞ°Ğ· '{order.title}' Ğ±Ñ‹Ğ» Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½ Ğ·Ğ°ĞºĞ°Ğ·Ñ‡Ğ¸ĞºĞ¾Ğ¼",
            "order_cancelled",
            order.id
        )
    elif current_user.id == order.freelancer_id:
        create_notification(
            db,
            order.client_id,
            "Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½",
            f"Ğ—Ğ°ĞºĞ°Ğ· '{order.title}' Ğ±Ñ‹Ğ» Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ĞµĞ¼",
            "order_cancelled",
            order.id
        )
    
    db.commit()
    return {"message": "Order cancelled successfully", "order_id": order_id}

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ñ‡Ğ°Ñ‚Ğ°
@app.get("/orders/{order_id}/messages")
async def get_chat_messages(
    order_id: int, 
    current_user: models.User = Depends(get_current_user), 
    db: Session = Depends(get_db)
):
    try:
        order = db.query(models.Order).filter(models.Order.id == order_id).first()
        if not order:
            raise HTTPException(status_code=404, detail="Order not found")
        
        if current_user.id not in [order.client_id, order.freelancer_id]:
            raise HTTPException(status_code=403, detail="Not authorized")
        
        messages = db.query(models.ChatMessage).filter(
            models.ChatMessage.order_id == order_id
        ).order_by(models.ChatMessage.created_at).all()
        
        return [
            {
                "id": msg.id,
                "sender_id": msg.sender_id,
                "sender_name": msg.sender.full_name,
                "message": msg.message,
                "is_own": msg.sender_id == current_user.id,
                "created_at": msg.created_at,
                "message_type": msg.message_type
            }
            for msg in messages
        ]
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error in get_chat_messages: {e}")
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ (REST)
@app.post("/orders/{order_id}/messages")
async def send_message(
    order_id: int,
    message_data: ChatMessageCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        print(f"ğŸ“¨ Sending message to order {order_id} from user {current_user.id}")
        
        order = db.query(models.Order).filter(models.Order.id == order_id).first()
        if not order:
            raise HTTPException(status_code=404, detail="Order not found")
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğº Ğ·Ğ°ĞºĞ°Ğ·Ñƒ
        if current_user.id not in [order.client_id, order.freelancer_id]:
            raise HTTPException(status_code=403, detail="Not authorized to send messages")
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¿ÑƒÑÑ‚Ğ¾Ğµ
        if not message_data.message or not message_data.message.strip():
            raise HTTPException(status_code=400, detail="Message cannot be empty")
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        message = models.ChatMessage(
            order_id=order_id,
            sender_id=current_user.id,
            message=message_data.message.strip(),
            message_type=message_data.message_type
        )
        
        db.add(message)
        db.commit()
        db.refresh(message)
        
        print(f"âœ… Message saved: ID {message.id}, length: {len(message.message)}")
        
        # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ñ‚ĞµĞ»Ñ Ñ‡ĞµÑ€ĞµĞ· WebSocket
        receiver_id = None
        if order.client_id == current_user.id and order.freelancer_id:
            receiver_id = order.freelancer_id
        elif order.freelancer_id == current_user.id:
            receiver_id = order.client_id
            
        if receiver_id:
            create_notification(
                db,
                receiver_id,
                "ĞĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ",
                f"ĞĞ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² Ğ·Ğ°ĞºĞ°Ğ·Ğµ '{order.title}'",
                "message",
                order_id
            )
        
        db.commit()
        
        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚
        response = {
            "id": message.id,
            "message": message.message,
            "created_at": message.created_at.isoformat(),
            "sender_id": message.sender_id,
            "order_id": message.order_id,
            "message_type": message.message_type
        }
        
        print(f"ğŸ“¤ Sending response: {response}")
        return response
        
    except HTTPException:
        db.rollback()
        raise
    except Exception as e:
        db.rollback()
        print(f"âŒ Error in send_message: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
@app.get("/users/{user_id}/rating")
async def get_user_rating(user_id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    reviews = db.query(models.Review).filter(
        models.Review.reviewed_user_id == user_id
    ).all()
    
    total_rating = sum(r.rating for r in reviews)
    review_count = len(reviews)
    avg_rating = total_rating / review_count if review_count > 0 else 0
    
    return {
        "rating": avg_rating,
        "review_count": review_count,
        "pro_eligible": avg_rating >= 4.5 and review_count >= 10,
        "level": "PRO" if avg_rating >= 4.5 else "Standard",
    }

# ĞĞºÑ‚Ğ¸Ğ²Ğ°Ñ†Ğ¸Ñ PRO ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
@app.patch("/users/pro")
async def update_pro_status(
    subscription_type: str,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ»Ğ° Ğ±Ñ‹ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ½Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¾Ğ¹
    current_user.is_pro = True
    current_user.pro_expires_at = datetime.utcnow() + timedelta(days=30)  # 30 Ğ´Ğ½ĞµĞ¹ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ°
    current_user.pro_subscription_type = subscription_type
    
    db.commit()
    
    return {
        "message": "PRO ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½",
        "expires_at": current_user.pro_expires_at,
        "subscription_type": subscription_type
    }

# ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
@app.patch("/orders/{order_id}/promote")
async def promote_order(
    order_id: int,
    promotion_type: str = "urgent",
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    order = db.query(models.Order).filter(models.Order.id == order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    if order.client_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ·Ğ´ĞµÑÑŒ Ğ±Ñ‹Ğ»Ğ° Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ñ‹
    order.is_promoted = True
    order.promotion_type = promotion_type
    order.promoted_until = datetime.utcnow() + timedelta(days=1)  # 24 Ñ‡Ğ°ÑĞ° Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ
    
    db.commit()
    
    return {
        "message": f"Ğ—Ğ°ĞºĞ°Ğ· Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚ ĞºĞ°Ğº {promotion_type}",
        "promoted_until": order.promoted_until,
        "promotion_type": promotion_type
    }

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ¾Ğ² Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
@app.get("/templates")
async def get_templates(db: Session = Depends(get_db)):
    templates = [
        {
            "id": 1,
            "name": "Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿Ğ°",
            "category": "Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½",
            "template": "Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğº Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿Ñƒ:\n\n1. Ğ¡Ñ‚Ğ¸Ğ»ÑŒ Ğ¸ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ñ:\n   â€¢ ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¼, ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ ÑÑ‚Ğ¸Ğ»ÑŒ\n   â€¢ Ğ’ĞµĞºÑ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚\n   â€¢ ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ñ‹Ğ¹ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½\n\n2. Ğ¦Ğ²ĞµÑ‚Ğ¾Ğ²Ğ°Ñ Ğ¿Ğ°Ğ»Ğ¸Ñ‚Ñ€Ğ°:\n   â€¢ ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ²ĞµÑ‚: #[Ñ†Ğ²ĞµÑ‚1]\n   â€¢ Ğ”Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹: #[Ñ†Ğ²ĞµÑ‚2]\n   â€¢ ĞĞºÑ†ĞµĞ½Ñ‚Ğ½Ñ‹Ğ¹: #[Ñ†Ğ²ĞµÑ‚3]\n\n3. Ğ¡Ñ€Ğ¾ĞºĞ¸:\n   â€¢ Ğ¡Ñ€Ğ¾Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ: [Ğ´Ğ½ĞµĞ¹] Ğ´Ğ½ĞµĞ¹\n   â€¢ ĞŸÑ€Ğ°Ğ²ĞºĞ¸: 3 Ñ€Ğ°ÑƒĞ½Ğ´Ğ°\n\nĞ‘ÑĞ´Ğ¶ĞµÑ‚: [ÑÑƒĞ¼Ğ¼Ğ°] â‚½"
        },
        {
            "id": 2,
            "name": "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ°Ğ¹Ñ‚Ğ°",
            "category": "Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°",
            "template": "Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ÑĞ°Ğ¹Ñ‚Ğ°:\n\n1. Ğ¢Ğ¸Ğ¿ ÑĞ°Ğ¹Ñ‚Ğ°: [Ñ‚Ğ¸Ğ¿]\n2. Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ: [Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ]\n3. ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ†ĞµĞ»Ğ¸: [Ñ†ĞµĞ»Ğ¸]\n\n4. Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:\n   â€¢ ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑÑ‚ĞºĞ°\n   â€¢ CMS\n   â€¢ Ğ¤Ğ¾Ñ€Ğ¼Ğ° Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ¹ ÑĞ²ÑĞ·Ğ¸\n   â€¢ SEO-Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ\n\n5. Ğ¡Ñ€Ğ¾ĞºĞ¸ Ğ¸ Ğ±ÑĞ´Ğ¶ĞµÑ‚:\n   â€¢ Ğ¡Ñ€Ğ¾Ğº Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸: [Ğ´Ğ½ĞµĞ¹] Ğ´Ğ½ĞµĞ¹\n   â€¢ Ğ‘ÑĞ´Ğ¶ĞµÑ‚: [ÑÑƒĞ¼Ğ¼Ğ°] â‚½"
        },
        {
            "id": 3,
            "name": "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğ¸Ğ½Ğ³ ÑÑ‚Ğ°Ñ‚ÑŒĞ¸",
            "category": "ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğ¸Ğ½Ğ³",
            "template": "Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğº ÑÑ‚Ğ°Ñ‚ÑŒĞµ:\n\n1. Ğ¢ĞµĞ¼Ğ°: [Ñ‚ĞµĞ¼Ğ°]\n2. Ğ¦ĞµĞ»ÑŒ: [Ñ†ĞµĞ»ÑŒ]\n3. Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ: [Ğ¦Ğ]\n\n4. Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ñ‚Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ:\n   â€¢ ĞĞ±ÑŠĞµĞ¼: [ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²]\n   â€¢ Ğ£Ğ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ: 95%+\n   â€¢ ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ ÑĞ»Ğ¾Ğ²Ğ°: [ÑĞ»Ğ¾Ğ²Ğ°]\n\n5. Ğ¡Ñ€Ğ¾ĞºĞ¸ Ğ¸ Ğ¾Ğ¿Ğ»Ğ°Ñ‚Ğ°:\n   â€¢ Ğ¡Ñ€Ğ¾Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ: [Ğ´Ğ½ĞµĞ¹] Ğ´Ğ½ĞµĞ¹\n   â€¢ ĞĞ¿Ğ»Ğ°Ñ‚Ğ°: [ÑÑƒĞ¼Ğ¼Ğ°] â‚½"
        }
    ]
    return templates

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
@app.post("/orders/promoted")
async def create_promoted_order(
    order: OrderCreate,
    is_urgent: bool = False,
    is_premium: bool = False,
    placement_type: str = "urgent",
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    if current_user.is_freelancer:
        raise HTTPException(status_code=400, detail="Freelancers cannot create orders")
    
    db_order = models.Order(
        title=order.title,
        description=order.description,
        requirements=order.requirements,
        budget=order.budget,
        client_id=current_user.id,
        deadline=order.deadline,
        category=order.category,
        is_urgent=is_urgent,
        is_premium=is_premium,
        placement_type=placement_type
    )
    
    db.add(db_order)
    
    # Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ¾Ğ²
    freelancers = db.query(models.User).filter(
        models.User.is_freelancer == True,
        models.User.is_active == True
    ).limit(50).all()  # Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ğ»Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    
    for freelancer in freelancers:
        create_notification(
            db,
            freelancer.id,
            "ğŸ”¥ ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼ Ğ·Ğ°ĞºĞ°Ğ· Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½!",
            f"ĞĞ¾Ğ²Ñ‹Ğ¹ {placement_type} Ğ·Ğ°ĞºĞ°Ğ·: '{order.title}' Ğ·Ğ° {order.budget} Ñ€ÑƒĞ±.",
            "new_order_premium",
            db_order.id
        )
    
    db.commit()
    db.refresh(db_order)
    
    return db_order

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ€Ğ¾Ñ‡Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
@app.get("/orders/urgent")
async def get_urgent_orders(
    skip: int = 0,
    limit: int = 20,
    db: Session = Depends(get_db)
):
    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹, Ñƒ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ´ĞµĞ´Ğ»Ğ°Ğ¹Ğ½ Ğ¼ĞµĞ½ÑŒÑˆĞµ Ñ‡ĞµĞ¼ Ñ‡ĞµÑ€ĞµĞ· 24 Ñ‡Ğ°ÑĞ°
    twenty_four_hours_from_now = datetime.utcnow() + timedelta(hours=24)
    
    orders = db.query(models.Order).filter(
        models.Order.status == "open",
        models.Order.deadline <= twenty_four_hours_from_now,
        models.Order.deadline > datetime.utcnow()  # Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğµ Ğ´ĞµĞ´Ğ»Ğ°Ğ¹Ğ½Ñ‹
    ).order_by(models.Order.deadline.asc()).offset(skip).limit(limit).all()
    
    return orders

# Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ°
@app.post("/reviews")
async def create_review(
    review: ReviewCreate,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    order = db.query(models.Order).filter(models.Order.id == review.order_id).first()
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    if order.status != "completed":
        raise HTTPException(status_code=400, detail="Can only review completed orders")
    
    if current_user.id not in [order.client_id, order.freelancer_id]:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    reviewed_user_id = order.freelancer_id if current_user.id == order.client_id else order.client_id
    
    existing_review = db.query(models.Review).filter(
        models.Review.order_id == review.order_id,
        models.Review.reviewer_id == current_user.id
    ).first()
    
    if existing_review:
        raise HTTPException(status_code=400, detail="Already reviewed")
    
    if not 1 <= review.rating <= 5:
        raise HTTPException(status_code=400, detail="Rating must be between 1 and 5")
    
    db_review = models.Review(
        order_id=review.order_id,
        reviewer_id=current_user.id,
        reviewed_user_id=reviewed_user_id,
        rating=review.rating,
        comment=review.comment
    )
    
    db.add(db_review)
    
    # ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ€ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    reviewed_user = db.query(models.User).filter(models.User.id == reviewed_user_id).first()
    if reviewed_user:
        all_reviews = db.query(models.Review).filter(
            models.Review.reviewed_user_id == reviewed_user_id
        ).all()
        
        total_rating = sum(r.rating for r in all_reviews) + review.rating
        review_count = len(all_reviews) + 1
        reviewed_user.rating = total_rating / review_count
        reviewed_user.review_count = review_count
    
    db.commit()
    db.refresh(db_review)
    
    return {
        "id": db_review.id,
        "rating": db_review.rating,
        "comment": db_review.comment,
        "created_at": db_review.created_at
    }

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (Ñ Ğ¿Ğ°Ğ³Ğ¸Ğ½Ğ°Ñ†Ğ¸ĞµĞ¹)
@app.get("/users/{user_id}/reviews")
async def get_user_reviews(
    user_id: int, 
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    try:
        skip = (page - 1) * limit
        
        reviews = db.query(models.Review).filter(
            models.Review.reviewed_user_id == user_id
        ).order_by(models.Review.created_at.desc()).offset(skip).limit(limit).all()
        
        return [
            {
                "id": r.id,
                "rating": r.rating,
                "comment": r.comment,
                "reply": r.reply,
                "reviewer_name": r.reviewer.full_name,
                "reviewer_id": r.reviewer_id,
                "order_title": r.order.title,
                "order_id": r.order_id,
                "created_at": r.created_at,
                "updated_at": r.updated_at
            }
            for r in reviews
        ]
        
    except Exception as e:
        print(f"Error getting user reviews: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ½Ğ° Ğ¾Ñ‚Ğ·Ñ‹Ğ² (Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»Ñ)
@app.post("/reviews/{review_id}/reply")
async def add_review_reply(
    review_id: int,
    reply_text: str = Query(..., min_length=1),
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        review = db.query(models.Review).filter(models.Review.id == review_id).first()
        if not review:
            raise HTTPException(status_code=404, detail="Review not found")
        
        if review.reviewed_user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Not authorized to reply")
        
        review.reply = reply_text
        review.updated_at = datetime.utcnow()
        
        db.commit()
        
        return {
            "message": "Reply added successfully",
            "review_id": review_id,
            "reply": reply_text
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error adding review reply: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ²
@app.get("/users/{user_id}/reviews/stats")
async def get_review_stats(user_id: int, db: Session = Depends(get_db)):
    try:
        reviews = db.query(models.Review).filter(
            models.Review.reviewed_user_id == user_id
        ).all()
        
        if not reviews:
            return {
                "total_reviews": 0,
                "average_rating": 0,
                "rating_distribution": {1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
                "recent_reviews": []
            }
        
        total_reviews = len(reviews)
        average_rating = sum(r.rating for r in reviews) / total_reviews
        
        # Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ·Ğ²ĞµĞ·Ğ´Ğ°Ğ¼
        rating_distribution = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
        for review in reviews:
            rating_distribution[review.rating] += 1
        
        # ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 5 Ğ¾Ñ‚Ğ·Ñ‹Ğ²Ğ¾Ğ²
        recent_reviews = [
            {
                "rating": r.rating,
                "comment": r.comment[:100] + "..." if r.comment and len(r.comment) > 100 else r.comment,
                "created_at": r.created_at
            }
            for r in sorted(reviews, key=lambda x: x.created_at, reverse=True)[:5]
        ]
        
        return {
            "total_reviews": total_reviews,
            "average_rating": round(average_rating, 1),
            "rating_distribution": rating_distribution,
            "recent_reviews": recent_reviews
        }
        
    except Exception as e:
        print(f"Error getting review stats: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
@app.get("/notifications", response_model=List[NotificationResponse])
async def get_notifications(
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    notifications = db.query(models.Notification).filter(
        models.Notification.user_id == current_user.id
    ).order_by(models.Notification.created_at.desc()).limit(50).all()
    
    return notifications

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ½ĞµĞ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ñ… ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
@app.get("/notifications/unread-count")
async def get_unread_notifications_count(
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        count = db.query(models.Notification).filter(
            models.Notification.user_id == current_user.id,
            models.Notification.is_read == False
        ).count()
        
        return {"count": count}
    except Exception as e:
        print(f"Error in get_unread_notifications_count: {e}")
        return {"count": 0}

# ĞÑ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğµ
@app.patch("/notifications/{notification_id}/read")
async def mark_notification_read(
    notification_id: int,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    notification = db.query(models.Notification).filter(
        models.Notification.id == notification_id,
        models.Notification.user_id == current_user.id
    ).first()
    
    if not notification:
        raise HTTPException(status_code=404, detail="Notification not found")
    
    notification.is_read = True
    db.commit()
    
    return {"message": "Notification marked as read"}

# ĞÑ‚Ğ¼ĞµÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ°Ğº Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ½Ñ‹Ğµ
@app.patch("/notifications/read-all")
async def mark_all_notifications_read(
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    notifications = db.query(models.Notification).filter(
        models.Notification.user_id == current_user.id,
        models.Notification.is_read == False
    ).all()
    
    for notification in notifications:
        notification.is_read = True
    
    db.commit()
    
    return {"message": f"{len(notifications)} notifications marked as read"}

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ
@app.get("/users/me", response_model=auth.UserResponse)
async def read_users_me(current_user: models.User = Depends(get_current_user)):
    return current_user

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
@app.get("/users/{user_id}")
async def get_user_profile(user_id: int, db: Session = Depends(get_db)):
    user = db.query(models.User).filter(models.User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    reviews = db.query(models.Review).filter(
        models.Review.reviewed_user_id == user_id
    ).all()
    
    completed_orders = db.query(models.Order).filter(
        models.Order.freelancer_id == user_id,
        models.Order.status == "completed"
    ).count() if user.is_freelancer else 0
    
    return {
        "id": user.id,
        "email": user.email,
        "full_name": user.full_name,
        "is_freelancer": user.is_freelancer,
        "rating": user.rating,
        "review_count": user.review_count,
        "completed_orders": completed_orders,
        "created_at": user.created_at
    }

# ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ñ
@app.patch("/users/me")
async def update_profile(
    full_name: Optional[str] = None,
    current_user: models.User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    if full_name:
        current_user.full_name = full_name
    
    db.commit()
    db.refresh(current_user)
    
    return current_user

# Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ½Ğ´Ğ¿Ğ¾Ğ¸Ğ½Ñ‚
@app.get("/")
async def root():
    return {"message": "Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² API Ğ’Ğ Ğ°Ğ±Ğ¾Ñ‚Ğµ!", "status": "online", "version": "2.0.0"}

# Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
@app.get("/stats")
async def get_stats(current_user: models.User = Depends(get_current_user), db: Session = Depends(get_db)):
    try:
        if current_user.is_freelancer:
            total_bids = db.query(models.Bid).filter(
                models.Bid.freelancer_id == current_user.id
            ).count()
            
            accepted_bids = db.query(models.Bid).filter(
                models.Bid.freelancer_id == current_user.id,
                models.Bid.status == "accepted"
            ).count()
            
            completed_orders = db.query(models.Order).filter(
                models.Order.freelancer_id == current_user.id,
                models.Order.status == "completed"
            ).count()
            
            total_earnings = db.query(models.Order).filter(
                models.Order.freelancer_id == current_user.id,
                models.Order.status == "completed"
            ).with_entities(func.sum(models.Order.budget)).scalar() or 0
            
            return {
                "total_bids": total_bids,
                "accepted_bids": accepted_bids,
                "completed_orders": completed_orders,
                "total_earnings": total_earnings,
                "rating": current_user.rating,
                "review_count": current_user.review_count
            }
        else:
            total_orders = db.query(models.Order).filter(
                models.Order.client_id == current_user.id,
                models.Order.status != 'cancelled'  # Ğ˜Ğ¡ĞšĞ›Ğ®Ğ§ĞĞ•Ğœ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ½Ñ‹Ğµ!
            ).count()
            
            completed_orders = db.query(models.Order).filter(
                models.Order.client_id == current_user.id,
                models.Order.status == "completed"
            ).count()
            
            total_spent_result = db.query(func.sum(models.Order.budget)).filter(
                models.Order.client_id == current_user.id,
                models.Order.status == 'completed'
            ).scalar()
            total_spent = total_spent_result or 0
            
            return {
                "total_orders": total_orders,
                "completed_orders": completed_orders,
                "total_spent": total_spent
            }
    except Exception as e:
        print(f"Error in get_stats: {e}")
        import traceback
        traceback.print_exc()
        # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¿Ñ€Ğ¸ Ğ¾ÑˆĞ¸Ğ±ĞºĞµ
        return {
            "total_orders": 0,
            "completed_orders": 0,
            "total_spent": 0,
            "total_earnings": 0,
            "accepted_bids": 0,
            "rating": 0
        }

# ĞŸĞ¾Ğ¸ÑĞº Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
@app.get("/orders/search")
async def search_orders(
    q: Optional[str] = Query(None),
    min_budget: Optional[float] = Query(None),
    max_budget: Optional[float] = Query(None),
    category: Optional[str] = Query(None),
    skip: int = 0,
    limit: int = 50,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    try:
        # Ğ”Ğ»Ñ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ¾Ğ² Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
        if current_user.is_freelancer:
            query = db.query(models.Order).filter(models.Order.status == "open")
        else:
            # Ğ”Ğ»Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¸Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
            query = db.query(models.Order).filter(models.Order.client_id == current_user.id)
        
        if q:
            query = query.filter(
                or_(
                    models.Order.title.ilike(f"%{q}%"),
                    models.Order.description.ilike(f"%{q}%")
                )
            )
        
        if min_budget:
            query = query.filter(models.Order.budget >= min_budget)
        
        if max_budget:
            query = query.filter(models.Order.budget <= max_budget)
        
        if category:
            query = query.filter(models.Order.category == category)
        
        orders = query.order_by(models.Order.created_at.desc()).offset(skip).limit(limit).all()
        return orders
        
    except Exception as e:
        print(f"Error in search_orders: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="Internal server error")

# ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
@app.get("/orders/categories")
async def get_categories(db: Session = Depends(get_db)):
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹ Ğ¸Ğ· Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ².
    """
    try:
        # ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ«Ğ™ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ: Ğ²Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
        categories = db.query(models.Order.category).filter(
            models.Order.category.isnot(None),
            models.Order.category != ''
        ).distinct().all()
        
        # ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº ĞºĞ¾Ñ€Ñ‚ĞµĞ¶ĞµĞ¹ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº ÑÑ‚Ñ€Ğ¾Ğº
        category_list = [category for (category,) in categories if category]
        
        # Ğ•ÑĞ»Ğ¸ Ğ½ĞµÑ‚ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¹, Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğµ
        if not category_list:
            category_list = ['Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½', 'Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°', 'ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğ¸Ğ½Ğ³', 'ĞœĞ°Ñ€ĞºĞµÑ‚Ğ¸Ğ½Ğ³', 'Ğ”Ñ€ÑƒĞ³Ğ¾Ğµ']
        
        print(f"ğŸ“Š ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹: {category_list}")
        return category_list
        
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ² /orders/categories: {e}")
        import traceback
        traceback.print_exc()
        return ['Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½', 'Ğ Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°', 'ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ°Ğ¹Ñ‚Ğ¸Ğ½Ğ³', 'ĞœĞ°Ñ€ĞºĞµÑ‚Ğ¸Ğ½Ğ³', 'Ğ”Ñ€ÑƒĞ³Ğ¾Ğµ']

# Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=False)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: models.py                                                              â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\models.py                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from sqlalchemy import Column, Integer, String, Float, Text, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    is_freelancer = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    rating = Column(Float, default=0.0)
    review_count = Column(Integer, default=0)
    
    # ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    orders_created = relationship("Order", 
                                 foreign_keys="Order.client_id",
                                 back_populates="client",
                                 lazy="dynamic")
    
    bids = relationship("Bid", 
                       back_populates="freelancer",
                       lazy="dynamic")
    
    # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ñ‹Ğµ ÑĞ²ÑĞ·Ğ¸
    notifications = relationship("Notification", 
                                back_populates="user",
                                lazy="dynamic")
    
    sent_messages = relationship("ChatMessage", 
                                foreign_keys="ChatMessage.sender_id",
                                back_populates="sender",
                                lazy="dynamic")
    
    given_reviews = relationship("Review", 
                                foreign_keys="Review.reviewer_id",
                                back_populates="reviewer",
                                lazy="dynamic")
    
    received_reviews = relationship("Review", 
                                   foreign_keys="Review.reviewed_user_id",
                                   back_populates="reviewed_user",
                                   lazy="dynamic")

class Order(Base):
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text, nullable=False)
    requirements = Column(Text)
    budget = Column(Float)
    client_id = Column(Integer, ForeignKey("users.id"))
    freelancer_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    status = Column(String, default="open")  # open, in_progress, completed, cancelled
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    deadline = Column(DateTime(timezone=True), nullable=True)
    category = Column(String, default="other")
    
    # ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    client = relationship("User", 
                         foreign_keys=[client_id],
                         back_populates="orders_created")
    
    assigned_freelancer = relationship("User", 
                                      foreign_keys=[freelancer_id])
    
    bids = relationship("Bid", 
                       back_populates="order",
                       lazy="dynamic",
                       cascade="all, delete-orphan")
    
    messages = relationship("ChatMessage", 
                           back_populates="order",
                           lazy="dynamic",
                           cascade="all, delete-orphan")
    
    reviews = relationship("Review", 
                          back_populates="order",
                          lazy="dynamic",
                          cascade="all, delete-orphan")

class Bid(Base):
    __tablename__ = "bids"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    freelancer_id = Column(Integer, ForeignKey("users.id"))
    amount = Column(Float)
    proposal = Column(Text)
    portfolio_links = Column(Text, nullable=True)
    status = Column(String, default="pending")  # pending, accepted, rejected
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # ĞÑ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    order = relationship("Order", back_populates="bids")
    freelancer = relationship("User", back_populates="bids")
    
class ChatMessage(Base):
    __tablename__ = "chat_messages"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"), nullable=False)
    sender_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    message = Column(Text, nullable=False)
    message_type = Column(String, default="text")
    is_read = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    order = relationship("Order", back_populates="messages")
    sender = relationship("User", 
                         foreign_keys=[sender_id],
                         back_populates="sent_messages")


class Notification(Base):
    __tablename__ = "notifications"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    title = Column(String, nullable=False)
    body = Column(Text, nullable=False)
    notification_type = Column(String)
    related_id = Column(Integer)
    is_read = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ
    user = relationship("User", 
                       foreign_keys=[user_id],
                       back_populates="notifications")

class Review(Base):
    __tablename__ = "reviews"
    
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"), nullable=False)
    reviewer_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    reviewed_user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    rating = Column(Integer, nullable=False)
    comment = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ñ
    order = relationship("Order", 
                        foreign_keys=[order_id],
                        back_populates="reviews")
    
    reviewer = relationship("User", 
                          foreign_keys=[reviewer_id],
                          back_populates="given_reviews")
    
    reviewed_user = relationship("User", 
                               foreign_keys=[reviewed_user_id],
                               back_populates="received_reviews")
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: test_api.py                                                            â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\test_api.py                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# backend/test_api.py
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import pytest
import requests
from datetime import datetime, timedelta

BASE_URL = "http://localhost:8000"

# === 1. Ğ¤Ğ˜ĞšĞ¡Ğ¢Ğ£Ğ Ğ« (TEST DATA) ===
@pytest.fixture
def test_user_client():
    """Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°."""
    return {"email": f"test_client_{datetime.now().timestamp()}@test.ru", "password": "test123", "full_name": "Test Client"}

@pytest.fixture
def test_user_freelancer():
    """Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ°."""
    return {"email": f"test_freelancer_{datetime.now().timestamp()}@test.ru", "password": "test123", "full_name": "Test Freelancer", "is_freelancer": True}

# === 2. Ğ¢Ğ•Ğ¡Ğ¢Ğ« ĞĞ’Ğ¢ĞĞ Ğ˜Ğ—ĞĞ¦Ğ˜Ğ˜ ===
class TestAuth:
    def test_register_client(self, test_user_client):
        """Ğ¢ĞµÑÑ‚ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°."""
        response = requests.post(f"{BASE_URL}/register", json=test_user_client)
        assert response.status_code == 200
        data = response.json()
        assert data["email"] == test_user_client["email"]
        assert "id" in data
        print(f"âœ… ĞšĞ»Ğ¸ĞµĞ½Ñ‚ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {data['email']}")

    def test_login_and_get_token(self, test_user_client):
        """Ğ¢ĞµÑÑ‚ Ğ²Ñ…Ğ¾Ğ´Ğ° Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ JWT Ñ‚Ğ¾ĞºĞµĞ½Ğ°."""
        # 1. Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼
        reg_response = requests.post(f"{BASE_URL}/register", json=test_user_client)
        # 2. ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ²Ğ¾Ğ¹Ñ‚Ğ¸ (OAuth2 password flow)
        form_data = {
            'username': test_user_client['email'],
            'password': test_user_client['password']
        }
        login_response = requests.post(f"{BASE_URL}/token", data=form_data)
        assert login_response.status_code == 200
        token_data = login_response.json()
        assert "access_token" in token_data
        assert token_data["token_type"] == "bearer"
        print(f"âœ… Ğ›Ğ¾Ğ³Ğ¸Ğ½ ÑƒÑĞ¿ĞµÑˆĞµĞ½, Ñ‚Ğ¾ĞºĞµĞ½ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½")

# === 3. Ğ¢Ğ•Ğ¡Ğ¢Ğ« Ğ—ĞĞšĞĞ—ĞĞ’ (ĞŸĞĞ›ĞĞ«Ğ™ Ğ¦Ğ˜ĞšĞ›) ===
class TestOrderFullCycle:
    @pytest.fixture(autouse=True)
    def setup(self, test_user_client, test_user_freelancer):
        """Ğ¤Ğ¸ĞºÑÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¸Ñ… Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ² Ğ¿ĞµÑ€ĞµĞ´ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¼ Ñ‚ĞµÑÑ‚Ğ¾Ğ¼ Ñ†Ğ¸ĞºĞ»Ğ°."""
        # Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ¸Ğ¼ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
        requests.post(f"{BASE_URL}/register", json=test_user_client)
        client_login = requests.post(f"{BASE_URL}/token", data={'username': test_user_client['email'], 'password': test_user_client['password']})
        self.client_token = client_login.json()["access_token"]
        self.client_headers = {"Authorization": f"Bearer {self.client_token}"}

        # Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ¸Ğ¼ Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ°
        requests.post(f"{BASE_URL}/register", json=test_user_freelancer)
        freelancer_login = requests.post(f"{BASE_URL}/token", data={'username': test_user_freelancer['email'], 'password': test_user_freelancer['password']})
        self.freelancer_token = freelancer_login.json()["access_token"]
        self.freelancer_headers = {"Authorization": f"Bearer {self.freelancer_token}"}

        self.order_id = None
        self.bid_id = None
        yield

    def test_1_create_order_by_client(self):
        """ĞšĞ»Ğ¸ĞµĞ½Ñ‚ ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·."""
        order_data = {
            "title": "Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· Ğ½Ğ° Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿Ğ°",
            "description": "ĞÑƒĞ¶Ğ½Ğ¾ Ğ½Ğ°Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ€Ñ‚Ğ°Ğ¿Ğ°",
            "requirements": "ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¼, Ğ²ĞµĞºÑ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚",
            "budget": 5000.0,
            "deadline": (datetime.utcnow() + timedelta(days=7)).isoformat() + "Z",
            "category": "Ğ”Ğ¸Ğ·Ğ°Ğ¹Ğ½"
        }
        response = requests.post(f"{BASE_URL}/orders", json=order_data, headers=self.client_headers)
        assert response.status_code == 200
        order = response.json()
        assert order["title"] == order_data["title"]
        assert order["status"] == "open"
        self.order_id = order["id"]
        print(f"âœ… Ğ—Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½, ID: {self.order_id}")

    def test_2_freelancer_creates_bid(self):
        """Ğ¤Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ Ğ·Ğ°ĞºĞ°Ğ· Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº (Ğ±Ğ¸Ğ´)."""
        # Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·, ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ ĞµÑ‰Ğµ Ğ½ĞµÑ‚
        if not self.order_id:
            self.test_1_create_order_by_client()

        bid_data = {
            "order_id": self.order_id,
            "amount": 4500.0,
            "proposal": "Ğ¯ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ñ Ğ²Ğ°Ñˆ Ğ»Ğ¾Ğ³Ğ¾Ñ‚Ğ¸Ğ¿ Ğ·Ğ° 5 Ğ´Ğ½ĞµĞ¹, Ğ²Ğ¾Ñ‚ Ğ¼Ğ¾Ğµ Ğ¿Ğ¾Ñ€Ñ‚Ñ„Ğ¾Ğ»Ğ¸Ğ¾...",
            "portfolio_links": "https://myportfolio.com/example1, https://github.com/mywork"
        }
        response = requests.post(f"{BASE_URL}/bids", json=bid_data, headers=self.freelancer_headers)
        assert response.status_code == 200
        bid = response.json()
        assert bid["amount"] == bid_data["amount"]
        self.bid_id = bid["id"]
        print(f"âœ… ĞÑ‚ĞºĞ»Ğ¸Ğº ÑĞ¾Ğ·Ğ´Ğ°Ğ½, ID: {self.bid_id}")

    def test_3_client_accepts_bid(self):
        """ĞšĞ»Ğ¸ĞµĞ½Ñ‚ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº Ñ„Ñ€Ğ¸Ğ»Ğ°Ğ½ÑĞµÑ€Ğ°."""
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ· Ğ¸ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº, ĞµÑĞ»Ğ¸ Ğ¸Ñ… Ğ½ĞµÑ‚
        if not self.bid_id:
            self.test_2_freelancer_creates_bid()

        response = requests.patch(f"{BASE_URL}/bids/{self.bid_id}/accept", headers=self.client_headers)
        assert response.status_code == 200
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ
        order_response = requests.get(f"{BASE_URL}/orders/{self.order_id}", headers=self.client_headers)
        order = order_response.json()
        assert order["status"] == "in_progress"
        assert order["freelancer_id"] is not None
        print(f"âœ… ĞÑ‚ĞºĞ»Ğ¸Ğº Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚, Ğ·Ğ°ĞºĞ°Ğ· Ğ² Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ")

    def test_4_send_chat_message(self):
        """Ğ£Ñ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ° Ğ¾Ğ±Ğ¼ĞµĞ½Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸ÑĞ¼Ğ¸ Ğ² Ñ‡Ğ°Ñ‚Ğµ."""
        if not self.order_id:
            self.test_1_create_order_by_client()

        # ĞšĞ»Ğ¸ĞµĞ½Ñ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ
        message_data = {"message": "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ! ĞšĞ¾Ğ³Ğ´Ğ° ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ?", "message_type": "text"}
        response = requests.post(f"{BASE_URL}/orders/{self.order_id}/messages", json=message_data, headers=self.client_headers)
        assert response.status_code == 200
        print("âœ… Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² Ñ‡Ğ°Ñ‚ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾")

    def test_5_client_completes_order(self):
        """ĞšĞ»Ğ¸ĞµĞ½Ñ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·."""
        # 1. Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·, ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ ĞµÑ‰Ğµ Ğ½ĞµÑ‚
        if not self.order_id:
            self.test_1_create_order_by_client()
        
        # 2. Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº, ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ ĞµÑ‰Ğµ Ğ½ĞµÑ‚
        if not self.bid_id:
            self.test_2_freelancer_creates_bid()
        
        # 3. ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº, ĞµÑĞ»Ğ¸ Ğ¾Ğ½ ĞµÑ‰Ğµ Ğ½Ğµ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        order_response = requests.get(f"{BASE_URL}/orders/{self.order_id}", headers=self.client_headers)
        current_order = order_response.json()
        
        if current_order["status"] != "in_progress":
            # ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº
            print(f"ğŸ”„ ĞŸÑ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµĞ¼ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº {self.bid_id} Ğ´Ğ»Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ° {self.order_id}")
            accept_response = requests.patch(f"{BASE_URL}/bids/{self.bid_id}/accept", headers=self.client_headers)
            assert accept_response.status_code == 200, f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ÑŒ Ğ¾Ñ‚ĞºĞ»Ğ¸Ğº: {accept_response.text}"
            
            # Ğ”Ğ°ĞµĞ¼ Ğ²Ñ€ĞµĞ¼Ñ Ğ½Ğ° Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°
            import time
            time.sleep(0.5)
        
        # 4. Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
        print(f"âœ… Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ· {self.order_id}")
        response = requests.patch(f"{BASE_URL}/orders/{self.order_id}/complete", headers=self.client_headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Text: {response.text}")
        
        assert response.status_code == 200, f"ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·: {response.text}"
        
        # 5. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ
        order_response = requests.get(f"{BASE_URL}/orders/{self.order_id}", headers=self.client_headers)
        order = order_response.json()
        assert order["status"] == "completed", f"ĞĞ¶Ğ¸Ğ´Ğ°Ğ»ÑÑ ÑÑ‚Ğ°Ñ‚ÑƒÑ 'completed', Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ '{order['status']}'"
        print(f"âœ… Ğ—Ğ°ĞºĞ°Ğ· ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½")

# === Ğ—ĞĞŸĞ£Ğ¡Ğš Ğ’Ğ¡Ğ•Ğ¥ Ğ¢Ğ•Ğ¡Ğ¢ĞĞ’ ===
if __name__ == "__main__":
    # Ğ—Ğ°Ğ¿ÑƒÑĞº Ñ Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¾Ğ¼ Ğ¸ Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞº
    pytest.main(["-v", "-s", "--tb=short", "-W", "ignore::DeprecationWarning"])
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Ğ¤ĞĞ™Ğ›: websocket_manager.py                                                   â•‘
â•‘ ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ¯: Python                                                            â•‘
â•‘ ĞŸĞĞ›ĞĞ«Ğ™ ĞŸĞ£Ğ¢Ğ¬: C:\Users\MSI\Desktop\InWork\backend\websocket_manager.py         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from typing import Dict, Set
from fastapi import WebSocket
import json

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[int, WebSocket] = {}
        self.user_rooms: Dict[int, Set[str]] = {}

    async def connect(self, websocket: WebSocket, user_id: int, room_id: str):
        await websocket.accept()
        self.active_connections[user_id] = websocket
        if user_id not in self.user_rooms:
            self.user_rooms[user_id] = set()
        self.user_rooms[user_id].add(room_id)
        print(f"âœ… User {user_id} connected to room {room_id}")

    def disconnect(self, user_id: int, room_id: str):
        if user_id in self.active_connections:
            del self.active_connections[user_id]
        if user_id in self.user_rooms and room_id in self.user_rooms[user_id]:
            self.user_rooms[user_id].remove(room_id)
        print(f"âŒ User {user_id} disconnected from room {room_id}")

    async def send_personal_message(self, message: dict, user_id: int):
        if user_id in self.active_connections:
            try:
                await self.active_connections[user_id].send_json(message)
            except Exception as e:
                print(f"Error sending to user {user_id}: {e}")

    async def broadcast_to_room(self, message: dict, room_id: str, exclude_user_id: int = None):
        for user_id, rooms in self.user_rooms.items():
            if room_id in rooms and user_id != exclude_user_id:
                await self.send_personal_message(message, user_id)

manager = ConnectionManager()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
